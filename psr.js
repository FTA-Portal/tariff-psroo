(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.TariffPSR = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){(function (){
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,3],$V1=[1,4],$V2=[1,5],$V3=[1,7],$V4=[1,8],$V5=[1,9],$V6=[1,10],$V7=[1,11],$V8=[1,12],$V9=[1,13],$Va=[1,14],$Vb=[1,15],$Vc=[1,16],$Vd=[5,7,8,9,11,14,15,16,17,18,20,21],$Ve=[1,27],$Vf=[1,32],$Vg=[1,33],$Vh=[1,34],$Vi=[1,35],$Vj=[5,7,8,9,11,14,15,16,17,18,20,21,22,23,25,26];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"(":6,")":7,"and":8,"or":9,"silent":10,"friendly":11,"CODE":12,"TEXT":13,"parameter":14,"text":15,"condition":16,"label":17,"from":18,"hslist":19,"except":20,"details":21,",":22,"-":23,"HS":24,"material":25,"extra":26,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"(",7:")",8:"and",9:"or",10:"silent",11:"friendly",12:"CODE",13:"TEXT",14:"parameter",15:"text",16:"condition",17:"label",18:"from",20:"except",21:"details",22:",",23:"-",24:"HS",25:"material",26:"extra"},
productions_: [0,[3,2],[4,3],[4,3],[4,3],[4,2],[4,4],[4,1],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[19,3],[19,3],[19,1],[19,3],[19,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return $$[$0-1];
break;
case 2:
this.$ = $$[$0-1];
break;
case 3:
this.$ = {and: [$$[$0-2], $$[$0]]};
break;
case 4:
this.$ = {or: [$$[$0-2], $$[$0]]};
break;
case 5:
this.$ = $$[$0]; this.$.silent = true;
break;
case 6:
this.$ = $$[$0-3]; this.$.friendly = this.$.friendly || {}; this.$.friendly[$$[$0-1]] = $$[$0].substr(1, $$[$0].length - 2);
break;
case 7:
this.$ = {code: $$[$0]};
break;
case 8: case 9: case 11: case 14: case 18: case 19:
this.$ = $$[$0-2]; this.$[$$[$0-1]] = $$[$0].substr(1, $$[$0].length - 2);
break;
case 10:
this.$ = $$[$0-2]; this.$[$$[$0-1]] = this.$[$$[$0-1]] || []; this.$[$$[$0-1]].push($$[$0].substr(1, $$[$0].length - 2));
break;
case 12: case 13:
this.$ = $$[$0-2]; this.$[$$[$0-1]] = $$[$0];
break;
case 15:
this.$ = {list: [$$[$0-2], $$[$0]]};
break;
case 16:
this.$ = {range: [$$[$0-2], $$[$0]]};
break;
case 17:
this.$ = {code: $$[$0].replace(/\./g, '')};
break;
}
},
table: [{3:1,4:2,6:$V0,10:$V1,12:$V2},{1:[3]},{5:[1,6],8:$V3,9:$V4,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb,21:$Vc},{4:17,6:$V0,10:$V1,12:$V2},{4:18,6:$V0,10:$V1,12:$V2},o($Vd,[2,7]),{1:[2,1]},{4:19,6:$V0,10:$V1,12:$V2},{4:20,6:$V0,10:$V1,12:$V2},{12:[1,21]},{13:[1,22]},{13:[1,23]},{13:[1,24]},{13:[1,25]},{19:26,24:$Ve},{19:28,24:$Ve},{13:[1,29]},{7:[1,30],8:$V3,9:$V4,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb,21:$Vc},o([5,7,8,9,14,15,16,17,18,20,21],[2,5],{11:$V5}),o([5,7,8,9],[2,3],{11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb,21:$Vc}),o([5,7,9],[2,4],{8:$V3,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb,21:$Vc}),{13:[1,31]},o($Vd,[2,8]),o($Vd,[2,9]),o($Vd,[2,10]),o($Vd,[2,11]),o($Vd,[2,12],{22:$Vf,23:$Vg,25:$Vh,26:$Vi}),o($Vj,[2,17]),o($Vd,[2,13],{22:$Vf,23:$Vg,25:$Vh,26:$Vi}),o($Vd,[2,14]),o($Vd,[2,2]),o($Vd,[2,6]),{19:36,24:$Ve},{19:37,24:$Ve},{13:[1,38]},{13:[1,39]},o([5,7,8,9,11,14,15,16,17,18,20,21,22],[2,15],{23:$Vg,25:$Vh,26:$Vi}),o([5,7,8,9,11,14,15,16,17,18,20,21,22,23],[2,16],{25:$Vh,26:$Vi}),o($Vj,[2,18]),o($Vj,[2,19])],
defaultActions: {6:[2,1]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 12;
break;
case 2:return 24;
break;
case 3:return 13;
break;
case 4:return 22;
break;
case 5:return 23;
break;
case 6:return 10
break;
case 7:return 14
break;
case 8:return 18
break;
case 9:return 15
break;
case 10:return 20
break;
case 11:return 16
break;
case 12:return 17
break;
case 13:return 21
break;
case 14:return 25
break;
case 15:return 26
break;
case 16:return 11
break;
case 17:return 6;
break;
case 18:return 7;
break;
case 19:return '<';
break;
case 20:return '>';
break;
case 21:return 8;
break;
case 22:return 9;
break;
case 23:return 5;
break;
}
},
rules: [/^(?:\s+)/,/^(?:[A-Z][A-Z0-9_]*)/,/^(?:[0-9][0-9.]*)/,/^(?:['][^']+['])/,/^(?:,)/,/^(?:-)/,/^(?:silent\b)/,/^(?:parameter\b)/,/^(?:from\b)/,/^(?:text\b)/,/^(?:except\b)/,/^(?:condition\b)/,/^(?:label\b)/,/^(?:details\b)/,/^(?:material\b)/,/^(?:extra\b)/,/^(?:friendly\b)/,/^(?:\()/,/^(?:\))/,/^(?:<)/,/^(?:>)/,/^(?:and\b)/,/^(?:or\b)/,/^(?:$)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}

}).call(this)}).call(this,require('_process'))
},{"_process":3}],2:[function(require,module,exports){
/**
 * @file Product Specific Rules Of Origin Module
 * 
 * @author Nahid Akbar
 * @year 2015
 * @copyright National ICT Australia (NICTA). All rights reserved.
 */

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var grammar = require("./grammar");
var uglifyHS = require('./uglifyHS');
var template = require('./template');

var PSR = function () {
  function PSR(tree, roo, vars) {
    _classCallCheck(this, PSR);

    this.tree = tree;
    this.roo = roo;

    this.official = formatOfficialHelper(this.tree);

    var codes = findAllCodesHelper(this.tree);
    var conditions = findAllConditionsHelper(codes);
    var labels = findAllLabelsHelper(codes);
    var details = findAllDetailsHelper(codes);

    var categoryById = {};
    var questionById = {};

    this.friendlyExpanded = {};
    this.friendlyGroupingException = {};

    this.categories = [];
    this.questions = [];
    this.outcomes = {};

    var that = this;

    roo.forEach(function (item, index) {
      item.item = index;
      switch (item.type) {
        case 'category':
          item.ruleFormattingStr = item.ruleFormattingStr || 'For {{hscode}}, the rule is {{friendlyRules}}.';
          item.conditionsExtraDetailsStr = item.conditionsExtraDetailsStr || 'The addition of "provided that" or "except from" in the rule creates additional parameters that must be followed for the product to qualify under this rule. Please follow closely the wording of the rule in selecting "yes" or "no" for this question.';
          item.details = item.details || '';
          item.questions = [];
          item.questionsById = {};
          that.categories.push(categoryById[item.itemIf] = item);
          break;
        case 'question':
          var included = item.itemIf.split(',').filter(function (itm) {
            return codes[itm] !== undefined;
          }).length > 0;
          if (included) {
            that.questions.push(item);

            var category = categoryById[item.parentCategory];

            category.questions.push(item);
            category.questionsById[item.itemIf] = item;

            if (item.itemIf in labels) {
              item.label = labels[item.itemIf];
            }
            if (item.details) {
              item.details = [item.details];
            } else {
              item.details = [];
            }
            if (item.itemIf in conditions) {
              item.conditions = conditions[item.itemIf];
              item.label = item.label.replace(/\?$/, " in accordance with the following rules?");
              item.details.push(category.conditionsExtraDetailsStr);
            }
            if (item.itemIf in details) {
              item.details.push(details[item.itemIf]);
            }

            var code = codes[item.itemIf];

            vars.parameter = code.parameter || undefined;

            item.label = template(item.label, vars);
            item.details = item.details.join('\n\n');

            item.details = template(item.details.replace(/(^\s*|\s*$)/g, ''), vars);
          }
          if (item.parentCategory) {
            that.friendlyGroupingException[item.itemIf] = item.parentCategory;
          }
          if (item.itemIfText) {
            that.friendlyExpanded[item.itemIf] = item.itemIfText;
          }
          questionById[item.itemIf] = item;
          break;
        case 'outcome':
          that.outcomes[item.itemIf] = item;
          break;
      }
    });

    Object.keys(codes).filter(function (code) {
      return !(code in questionById);
    }).forEach(function (code) {
      throw new Error("Question related to " + code + " does not exist.");
    });

    this.categories.forEach(function (category) {
      vars.friendlyRules = friendlyHelper(that.tree, that.friendlyExpanded, that.friendlyGroupingException, category.itemIf, category, vars).replace(/(^\s+|\s+$)/g, '').replace(/^(or |and | )*|( or| and| )*$/g, '');
      if (vars.friendlyRules) {
        category.friendlyRules = vars.friendlyRules = template(vars.friendlyRules, vars);
        category.details += (category.details ? '\n\n' : '') + category.ruleFormattingStr;
        category.details = template(category.details, vars);
      }
    });
    this.iterate();
  }

  _createClass(PSR, [{
    key: "dump",
    value: function dump() {
      return dumpHelper(this.tree);
    }
  }, {
    key: "iterate",
    value: function iterate(answers) {
      var answers = answers || {};
      var that = this;

      var blacklist = {};
      var values = {};
      var outcome = 'unclear';
      for (var q = 0; q < this.questions.length && outcome == 'unclear'; q++) {
        this.questions[q].visible = false;
      }
      for (var q = 0; q < this.questions.length && outcome == 'unclear'; q++) {
        var question = this.questions[q];
        if (!(question.itemIf in blacklist)) {
          question.visible = true;
          if (answers[question.itemIf] === true || answers[question.itemIf] === false) {
            values[question.itemIf] = answers[question.itemIf] === true;
            outcome = evaluateHelper(this.tree, values, blacklist, {});
          } else {
            break;
          }
        }
      }

      Object.keys(that.categories).map(function (cat) {
        return that.categories[cat];
      }).forEach(function (category) {
        category.visible = false;
        category.questions.forEach(function (question) {
          category.visible = category.visible || question.visible;
        });
      });

      return this.outcomes[outcome];
    }
  }], [{
    key: "parse",
    value: function parse(text) {
      var roo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var vars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return new PSR(grammar.parse(text), JSON.parse(JSON.stringify(roo)), vars);
    }
  }]);

  return PSR;
}();

function formatOfficialHelper(tree) {
  if (tree.silent) {
    return '';
  }

  if (tree.or) {
    return tree.or.map(formatOfficialHelper).filter(function (i) {
      return i;
    }).join(' or ');
  }
  if (tree.and) {
    return tree.and.map(formatOfficialHelper).filter(function (i) {
      return i;
    }).join(' or ');
  }

  if (tree.text) {
    return tree.text;
  } else {
    var output = '';
    if (tree.code) {
      //if (/^\d+$/.test(tree.code))
      //{
      //  output += ' materials of ' + uglifyHS(tree.code);
      //}
      //else
      //{
      output += tree.code.replace(/_/g, '');
      //}
    }
    if (tree.parameter) {
      output += '(' + tree.parameter + ')';
    }

    if (tree.except) {
      output += hslistToText(tree.except);
    }

    if (tree.condition) {
      output += ' ' + tree.condition;
    }
    return output.replace(/[ ]+/g, ' ').replace(/(^[ ]|[ ]$)/, '');
  }
}

function findAllCodesHelper(tree, output) {
  output = output || {};
  if (tree.or) {
    tree.or.forEach(function (x) {
      return findAllCodesHelper(x, output);
    });
  }
  if (tree.and) {
    tree.and.forEach(function (x) {
      return findAllCodesHelper(x, output);
    });
  }
  if (tree.code) {
    output[tree.code] = tree;
  }
  return output;
}

function findAllLabelsHelper(codes) {
  var output = {};
  Object.keys(codes).map(function (c) {
    return codes[c];
  }).filter(function (tree) {
    return tree.label;
  }).forEach(function (tree) {
    output[tree.code] = tree.label;
  });
  return output;
}

function findAllDetailsHelper(codes) {
  var output = {};

  Object.keys(codes).map(function (c) {
    return codes[c];
  }).filter(function (tree) {
    return tree.details;
  }).forEach(function (tree) {
    output[tree.code] = output[tree.code] || [];
    output[tree.code].push(tree.details);
  });

  return output;
}

function findAllConditionsHelper(codes) {
  var output = {};

  Object.keys(codes).map(function (c) {
    return codes[c];
  }).filter(function (tree) {
    return tree.except || tree.condition || tree.from;
  }).forEach(function (tree) {
    var list = output[tree.code] || [];
    if (tree.from) {
      list.push("provided that it is a change from " + hslistToText(tree.from));
    }
    if (tree.except) {
      list = list.concat(hslistToConditions(tree.except));
    }
    if (tree.condition) {
      tree.condition.forEach(function (cond) {
        return list.push(cond);
      });
    }
    output[tree.code] = list;
  });

  return output;
}

function hslistToConditions(except) {
  if (except.list) {
    return hslistToConditions(except.list[0]).concat(hslistToConditions(except.list[1]));
  }
  return ["provided that it is not a change from " + hslistToText(except)];
}

function hslistToText(except, index, list) {
  if (except.range) {
    return except.range.map(hslistToText).join(' through to ');
  } else if (except.list) {
    return except.list.map(hslistToText).join(', ');
  }

  var printMaterial = true;

  if (index && list && list[index - 1].material === except.material) {
    printMaterial = false;
  }

  return (printMaterial ? (except.material || 'materials') + ' of ' : '') + ("" + uglifyHS(except.code) + (except.extra ? ' ' + except.extra : ''));
}

// ==========================

function hslistToEncoded(except) {
  if (except.range) {
    return except.range.map(hslistToEncoded).join('-');
  }

  if (except.list) {
    return except.list.map(hslistToEncoded).join(',');
  }

  var output = '' + except.code;

  if (except.material) {
    output += " material '" + except.material + "'";
  }

  if (except.extra) {
    output += " extra '" + except.extra + "'";
  }

  return output;
}

var dumpHelper = function dumpHelper(tree) {
  var output = '';

  if (tree.or) {
    output = dumpHelper(tree.or[0]) + " or " + dumpHelper(tree.or[1]);
  }
  if (tree.and) {
    output = dumpHelper(tree.and[0]) + " and " + dumpHelper(tree.and[1]);
  }

  if (tree.code) {
    output += tree.code;
  }

  if (tree.parameter) {
    output += " parameter '" + tree.parameter + "'";
  }

  if (tree.from) {
    output += ' from ' + hslistToEncoded(tree.from);
  }

  if (tree.text) {
    output += " text '" + tree.text + "'";
  }

  if (tree.except) {
    output += ' except ' + hslistToEncoded(tree.except);
  }

  if (tree.condition) {
    tree.condition.forEach(function (condition) {
      return output += " condition '" + condition + "'";
    });
  }

  if (tree.label) {
    output += " label '" + tree.label + "'";
  }

  if (tree.details) {
    output += " details '" + tree.details + "'";
  }

  if (tree.silent) {
    output = "silent (" + output + ")";
  }

  if (tree.friendly) {
    Object.keys(tree.friendly).forEach(function (category) {
      output = "(" + output + ") friendly " + category + " '" + tree.friendly[category] + "'";
    });
  }

  return output;
};

var friendlyHelper = function friendlyHelper(tree, expanded, groups, category, settings, vars) {

  if (tree.friendly && category in tree.friendly) {
    return tree.friendly[category];
  }

  if (tree.silent) {
    return '';
  }

  if (tree.or) {
    return tree.or.map(function (rule) {
      return friendlyHelper(rule, expanded, groups, category, settings, vars);
    }).filter(function (i) {
      return i;
    }).join(' or ');
  }

  if (tree.and) {
    return tree.and.map(function (rule) {
      return friendlyHelper(rule, expanded, groups, category, settings, vars);
    }).filter(function (i) {
      return i;
    }).join(' and ');
  }

  if (tree.code && tree.code in groups) {
    if (groups[tree.code] !== category) {
      return '';
    }
  }

  if (tree.parameter) {
    vars.parameter = tree.parameter;
  }

  if (tree.text) {
    return template(tree.text, vars);
  } else if (settings.questionsById[tree.code].friendlyText) {
    return template(settings.questionsById[tree.code].friendlyText, vars);
  } else {
    var output = '';
    if (tree.code) {
      //if (/^\d+$/.test(tree.code))
      //{
      //  output += ' materials of ' + uglifyHS(tree.code);
      //}
      //else
      //{
      output += tree.code;
      //}
    }
    if (tree.parameter) {
      output += '(' + tree.parameter + ')';
    }

    if (tree.from) {
      output += ' from ' + hslistToText(tree.from);
    }

    if (tree.code in expanded) {
      if (tree.parameter) {
        output = expanded[tree.code] + (settings.hideItemCode ? '' : ' - ' + output);
      } else {
        output = expanded[tree.code] + (settings.hideItemCode ? '' : ' (' + output + ')');
      }
    }

    if (tree.except) {
      output += ' except from ' + hslistToText(tree.except);
    }

    if (tree.condition) {
      output += ' ' + tree.condition;
    }
    return template(output, vars);
  }
};

function evaluateHelper(tree, values, blacklist, whitelist) {
  if (tree.or) {
    var a = evaluateHelper(tree.or[0], values, blacklist, whitelist);
    var b = evaluateHelper(tree.or[1], values, blacklist, whitelist);
    if (a === 'applicable' || b === 'applicable') {
      return 'applicable';
    }
    if (a === 'unclear' || b === 'unclear') {
      return 'unclear';
    }
    return 'inapplicable';
  }
  if (tree.and) {
    var a = evaluateHelper(tree.and[0], values, blacklist, whitelist);
    var b = evaluateHelper(tree.and[1], values, blacklist, whitelist);
    if (a === 'applicable' && b === 'applicable') {
      return 'applicable';
    }
    if (a === 'inapplicable') {
      Object.keys(findAllCodesHelper(tree.and[1])).forEach(function (code) {
        if (!whitelist[code]) {
          blacklist[code] = !whitelist[code];
        }
      });
      return 'inapplicable';
    } else {
      Object.keys(findAllCodesHelper(tree)).forEach(function (code) {
        delete blacklist[code];
        whitelist[code] = true;
      });
    }
    if (b === 'inapplicable') {
      Object.keys(findAllCodesHelper(tree.and[0])).forEach(function (code) {
        if (!whitelist[code]) {
          blacklist[code] = true;
        }
      });
      return 'inapplicable';
    } else {
      Object.keys(findAllCodesHelper(tree)).forEach(function (code) {
        delete blacklist[code];
        whitelist[code] = true;
      });
    }
    return 'unclear';
  }
  if (values[tree.code] === undefined) {
    return 'unclear';
  } else if (values[tree.code] === true) {
    return 'applicable';
  } else {
    return 'inapplicable';
  }
}

module.exports = PSR;
},{"./grammar":1,"./template":4,"./uglifyHS":5}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
/**
 * @file Helper function
 * 
 * @author Nahid Akbar
 * @year 2015
 * @copyright National ICT Australia (NICTA). All rights reserved.
 */

"use strict";

var uglifyHS = require('./uglifyHS');

function template(str, vars) {
  var candidates = str.match(/\{\{[^\}]+\}\}/g);
  if (candidates) {
    candidates.forEach(function (candidate) {
      var variable = candidate.substr(2, candidate.length - 4);
      var value = false;
      switch (variable) {
        case 'subheading':
          if (vars.hscode) {
            value = uglifyHS(vars.hscode.replace(/[^0-9]/g, '').substr(0, 6));
          }
          break;
        case 'heading':
          if (vars.hscode) {
            value = uglifyHS(vars.hscode.replace(/[^0-9]/g, '').substr(0, 4));
          }
          break;
        case 'chapter':
          if (vars.hscode) {
            value = uglifyHS(vars.hscode.replace(/[^0-9]/g, '').substr(0, 2));
          }
          break;
        case 'hscode':
          if (vars.hscode) {
            value = uglifyHS(vars.hscode.replace(/[^0-9]/g, ''));
          }
          break;
        default:
          if (typeof vars[variable] === 'string') {
            value = vars[variable];
          }
          break;
      }
      if (value) {
        while (str.indexOf(candidate) !== -1) {
          str = str.replace(candidate, value);
        }
      } else {
        console.error('Variable ' + variable + ' could not be set.', str, vars);
      }
    });
  }
  return str;
}

module.exports = template;
},{"./uglifyHS":5}],5:[function(require,module,exports){
/**
 * @file Helper function
 * 
 * @author Nahid Akbar
 * @year 2015
 * @copyright National ICT Australia (NICTA). All rights reserved.
 */

"use strict";

function uglifyHS(code) {
  switch (code.length) {
    case 0:
      return '';
    case 1:
    case 2:
      return 'chapter ' + code;
    case 3:
    case 4:
      return 'heading ' + code;
    case 5:
    case 6:
      return 'subheading ' + code.substr(0, 4) + '.' + code.substr(4);
    default:
      return 'HS' + code.substr(0, 4) + '.' + code.substr(4, 2) + '.' + code.substr(6);
  }
}

module.exports = uglifyHS;
},{}]},{},[2])(2)
});
